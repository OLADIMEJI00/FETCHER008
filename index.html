<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Deriv Advanced Chart</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}body{font-family:Inter,Arial;background:#000;color:#fff;height:100vh;display:flex;flex-direction:column}
#bar{display:flex;flex-wrap:wrap;gap:8px;padding:10px;background:#111;border-bottom:1px solid #333;align-items:center;justify-content:center}
#bar select,#bar button,#bar input{padding:6px 10px;border-radius:6px;border:1px solid #333;background:#000;color:#fff;font-size:13px}
#bar button:hover{background:#222;cursor:pointer}.date-group{display:flex;gap:6px;align-items:center;border:1px solid #444;padding:6px;border-radius:6px;background:#0a0a0a}
.date-group label{font-size:12px;color:#0f0}.date-input{width:130px}#status{margin-left:auto;font-size:13px;padding:4px 8px;border-radius:4px}
.s-green{color:#0f0;background:rgba(0,255,0,0.1)}.s-yellow{color:#ff0;background:rgba(255,255,0,0.1)}.s-red{color:#f33;background:rgba(255,51,51,0.1)}
#main{flex:1;position:relative}#chart{width:100%;height:100%}#countdown{position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.8);color:#0f0;padding:6px 12px;border-radius:6px;font-weight:bold;z-index:100}
#spinner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:20px;border-radius:8px;display:none;z-index:200;text-align:center;min-width:300px}
#spinner-text{font-size:14px;margin-bottom:10px}#spinner-sub{font-size:12px;color:#888;margin-top:6px}#progress-bar{width:100%;height:8px;background:#333;border-radius:4px;overflow:hidden;margin-top:10px}
#progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#0f0,#3f3);transition:width 0.3s}#info{padding:8px 16px;background:#0a0a0a;border-bottom:1px solid #222;font-size:13px;color:#7efc8a;display:flex;justify-content:space-between}
#drawer{max-height:0;overflow:hidden;transition:max-height 0.3s;background:#0b0b0b;border-top:1px solid #333}#drawer.open{max-height:400px}#drawer-content{padding:20px}
.section{margin-bottom:20px}.section h3{color:#0ff;margin-bottom:10px;font-size:14px}.controls{display:flex;gap:10px;flex-wrap:wrap}#results{padding:12px;background:#050505;border-radius:6px;color:#7efc8a;font-size:13px}
@media (max-width:768px){#bar{gap:6px;padding:8px}.date-input{width:110px}#drawer-content{padding:12px}}
.strategy-btn{position:relative;display:inline-block}
.strategy-dropdown{display:none;position:absolute;background:#111;border:1px solid #333;border-radius:6px;min-width:200px;z-index:1000;margin-top:4px}
.strategy-dropdown.show{display:block}
.strategy-dropdown button{width:100%;text-align:left;padding:8px 12px;border:none;border-radius:0;background:#111;color:#fff;font-size:13px}
.strategy-dropdown button:hover{background:#222}
.strategy-dropdown button:first-child{border-radius:6px 6px 0 0}
.strategy-dropdown button:last-child{border-radius:0 0 6px 6px}
#strategyModal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:2000;justify-content:center;align-items:center}
#strategyModal.show{display:flex}
.modal-content{background:#111;border:1px solid #333;border-radius:8px;padding:20px;max-width:600px;width:90%}
.modal-content h3{color:#0ff;margin-bottom:15px}
.modal-content textarea{width:100%;height:300px;background:#000;border:1px solid #333;border-radius:6px;color:#0f0;padding:10px;font-family:monospace;font-size:12px;resize:vertical}
.modal-buttons{display:flex;gap:10px;margin-top:15px;justify-content:flex-end}
.modal-buttons button{padding:8px 16px;border-radius:6px;border:1px solid #333;background:#000;color:#fff;cursor:pointer}
.modal-buttons button:hover{background:#222}
.modal-buttons button.primary{background:#0f0;color:#000;border-color:#0f0}
.modal-buttons button.primary:hover{background:#3f3}
#strategyStatus{margin-left:8px;font-size:12px;color:#888}
</style>
</head>
<body>

<div id="bar">
<select id="cat"><option>Loading...</option></select>
<select id="sym"><option>Select symbol</option></select>
<select id="tf"><option value="60">1m</option><option value="300">5m</option><option value="900">15m</option><option value="3600">1h</option></select>
<select id="cnt"><option value="200">Last 200</option><option value="500">Last 500</option><option value="1000">Last 1K</option><option value="5000">Last 5K</option><option value="10000">Last 10K</option><option value="20000">Last 20K</option><option value="50000">Last 50K</option><option value="100000">Last 100K</option><option value="200000">Last 200K</option><option value="500000">Last 500K</option></select>
<button id="loadH">Load Historical</button>
<div class="date-group"><label>From:</label><input type="date" id="df" class="date-input" value=""><label>To:</label><input type="date" id="dt" class="date-input" value=""><button id="fetchR">Fetch Range</button></div>
<button id="live">Live Stream</button><button id="csv">CSV</button><button id="xlsx">XLSX</button><button id="bt">‚öô Backtest</button>
<div class="strategy-btn">
<button id="strategyBtn">üìä Strategy</button><span id="strategyStatus"></span>
<div id="strategyDropdown" class="strategy-dropdown">
<button id="stratImmediate">Immediate Signal Test</button>
<button id="stratRandom">Random Strategy</button>
<button id="stratPaste">Paste Custom JS</button>
<button id="stratUpload">Upload Strategy File</button>
</div>
</div>
<button id="scrollStart">‚èÆ</button><button id="scrollEnd">‚è≠</button>
<span id="status" class="s-red">üî¥ Disconnected</span>
</div>

<div id="info"><span id="infoTxt">Load data to begin</span><span id="pair">--</span></div>

<div id="main">
<div id="chart"></div>
<div id="countdown">00:00</div>
<div id="spinner"><div id="spinner-text">Loading...</div><div id="progress-bar"><div id="progress-fill"></div></div><div id="spinner-sub"></div></div>
</div>

<div id="drawer">
<div id="drawer-content">
<div class="section"><h3>Backtest Controls</h3>
<div class="controls">
<input type="number" id="slP" placeholder="SL %" step="0.1" style="width:100px;">
<input type="number" id="tpP" placeholder="TP %" step="0.1" style="width:100px;">
<input type="number" id="hold" placeholder="Hold candles" value="5" style="width:120px;">
<button id="runBt">Run Backtest</button><button id="clr">Clear</button>
</div>
</div>
<div class="section"><h3>Results</h3><div id="results">Run a backtest to see results</div></div>
</div>
</div>

<div id="strategyModal">
<div class="modal-content">
<h3>Paste Custom Strategy JavaScript</h3>
<textarea id="strategyCode" placeholder="// Paste your strategy function here
// Example:
// function customStrategy(data) {
//   const signals = [];
//   for (let i = 20; i < data.length; i++) {
//     if (data[i].close > data[i].open) {
//       signals.push({index: i, side: 'buy'});
//     }
//   }
//   return signals;
// }"></textarea>
<div class="modal-buttons">
<button id="modalCancel">Cancel</button>
<button id="modalApply" class="primary">Apply Strategy</button>
</div>
</div>
</div>

<input type="file" id="strategyFileInput" accept=".js,.txt" style="display:none">

<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

<script>
(function checkLibs(){if(typeof LightweightCharts==='undefined'||typeof XLSX==='undefined'){setTimeout(checkLibs,100);return}init()})();

function init(){
const APP_ID=1089,WS_URL=`wss://ws.derivws.com/websockets/v3?app_id=${APP_ID}`,MAX=500000,BATCH=5000;
let chart,series,socket,data=[],last=null,sym='',gran=60,markers=[],rangeStart=null,rangeEnd=null;
let currentStrategy=null,strategyInterval=null,customStrategyFunc=null,chartReady=false,countdownInterval=null;
let lastProcessedIndex=-1;

// Basic Price Action Indicators
function calculateReturns(data) {
  const returns = [];
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      returns.push(null);
    } else {
      returns.push(((data[i].close - data[i - 1].close) / data[i - 1].close) * 100);
    }
  }
  return returns;
}

function calculateHL(data) {
  return data.map(d => d.high - d.low);
}

function calculateOC(data) {
  return data.map(d => Math.abs(d.open - d.close));
}

function calculateBodyPct(data) {
  return data.map(d => {
    const range = d.high - d.low;
    return range === 0 ? 0 : (Math.abs(d.open - d.close) / range) * 100;
  });
}

// Moving Averages
function calculateSMA(data, period) {
  const sma = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      sma.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < period; j++) {
        sum += data[i - j].close;
      }
      sma.push(sum / period);
    }
  }
  return sma;
}

function calculateEMA(data, period) {
  const ema = [];
  const multiplier = 2 / (period + 1);
  let prevEMA = data[0].close;

  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      ema.push(data[i].close);
    } else {
      const currentEMA = (data[i].close - prevEMA) * multiplier + prevEMA;
      ema.push(currentEMA);
      prevEMA = currentEMA;
    }
  }
  return ema;
}

function calculateWMA(data, period) {
  const wma = [];
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      wma.push(null);
    } else {
      let weightedSum = 0;
      let weightSum = 0;
      for (let j = 0; j < period; j++) {
        const weight = period - j;
        weightedSum += data[i - j].close * weight;
        weightSum += weight;
      }
      wma.push(weightedSum / weightSum);
    }
  }
  return wma;
}

// RSI
function calculateRSI(data, period = 14) {
  const rsi = [];
  const gains = [];
  const losses = [];

  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      rsi.push(null);
      continue;
    }

    const change = data[i].close - data[i - 1].close;
    gains.push(change > 0 ? change : 0);
    losses.push(change < 0 ? Math.abs(change) : 0);

    if (i < period) {
      rsi.push(null);
    } else {
      const avgGain = gains.slice(-period).reduce((a, b) => a + b) / period;
      const avgLoss = losses.slice(-period).reduce((a, b) => a + b) / period;

      if (avgLoss === 0) {
        rsi.push(100);
      } else {
        const rs = avgGain / avgLoss;
        rsi.push(100 - (100 / (1 + rs)));
      }
    }
  }
  return rsi;
}

// MACD
function calculateMACD(data, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const fastEMA = calculateEMA(data, fastPeriod);
  const slowEMA = calculateEMA(data, slowPeriod);

  const macdLine = fastEMA.map((fast, i) => fast - slowEMA[i]);

  const macdData = macdLine.map((val, i) => ({ close: val || 0 }));
  const signalLine = calculateEMA(macdData, signalPeriod);

  const histogram = macdLine.map((macd, i) => macd - signalLine[i]);

  return { macdLine, signalLine, histogram };
}

// Stochastic Oscillator
function calculateStochastic(data, period = 14, smoothK = 3, smoothD = 3) {
  const stochK = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      stochK.push(null);
    } else {
      const slice = data.slice(i - period + 1, i + 1);
      const highest = Math.max(...slice.map(d => d.high));
      const lowest = Math.min(...slice.map(d => d.low));
      const k = lowest === highest ? 50 : ((data[i].close - lowest) / (highest - lowest)) * 100;
      stochK.push(k);
    }
  }
  
  const stochKSmooth = [];
  for (let i = 0; i < stochK.length; i++) {
    if (i < smoothK - 1 || stochK[i] === null) {
      stochKSmooth.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < smoothK; j++) {
        sum += stochK[i - j];
      }
      stochKSmooth.push(sum / smoothK);
    }
  }
  
  const stochD = [];
  for (let i = 0; i < stochKSmooth.length; i++) {
    if (i < smoothD - 1 || stochKSmooth[i] === null) {
      stochD.push(null);
    } else {
      let sum = 0;
      for (let j = 0; j < smoothD; j++) {
        sum += stochKSmooth[i - j];
      }
      stochD.push(sum / smoothD);
    }
  }
  
  return { k: stochKSmooth, d: stochD };
}

// ATR
function calculateATR(data, period = 14) {
  const tr = [];
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      tr.push(data[i].high - data[i].low);
    } else {
      const hl = data[i].high - data[i].low;
      const hc = Math.abs(data[i].high - data[i - 1].close);
      const lc = Math.abs(data[i].low - data[i - 1].close);
      tr.push(Math.max(hl, hc, lc));
    }
  }
  
  const atr = [];
  for (let i = 0; i < tr.length; i++) {
    if (i < period - 1) {
      atr.push(null);
    } else if (i === period - 1) {
      atr.push(tr.slice(0, period).reduce((a, b) => a + b) / period);
    } else {
      atr.push((atr[i - 1] * (period - 1) + tr[i]) / period);
    }
  }
  
  return atr;
}

// Bollinger Bands
function calculateBollingerBands(data, period = 20, stdDev = 2) {
  const sma = calculateSMA(data, period);
  const upper = [];
  const lower = [];
  const bandwidth = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      upper.push(null);
      lower.push(null);
      bandwidth.push(null);
    } else {
      const slice = data.slice(i - period + 1, i + 1);
      const mean = sma[i];
      const variance = slice.reduce((sum, d) => sum + Math.pow(d.close - mean, 2), 0) / period;
      const std = Math.sqrt(variance);
      upper.push(mean + stdDev * std);
      lower.push(mean - stdDev * std);
      bandwidth.push((upper[i] - lower[i]) / mean * 100);
    }
  }
  
  return { upper, middle: sma, lower, bandwidth };
}

// CCI
function calculateCCI(data, period = 20) {
  const cci = [];
  const typicalPrice = data.map(d => (d.high + d.low + d.close) / 3);
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      cci.push(null);
    } else {
      const slice = typicalPrice.slice(i - period + 1, i + 1);
      const sma = slice.reduce((a, b) => a + b) / period;
      const meanDev = slice.reduce((sum, val) => sum + Math.abs(val - sma), 0) / period;
      cci.push(meanDev === 0 ? 0 : (typicalPrice[i] - sma) / (0.015 * meanDev));
    }
  }
  
  return cci;
}

// Williams %R
function calculateWilliamsR(data, period = 14) {
  const willR = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      willR.push(null);
    } else {
      const slice = data.slice(i - period + 1, i + 1);
      const highest = Math.max(...slice.map(d => d.high));
      const lowest = Math.min(...slice.map(d => d.low));
      willR.push(lowest === highest ? -50 : ((highest - data[i].close) / (highest - lowest)) * -100);
    }
  }
  
  return willR;
}

// ROC (Rate of Change)
function calculateROC(data, period = 12) {
  const roc = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period) {
      roc.push(null);
    } else {
      roc.push(((data[i].close - data[i - period].close) / data[i - period].close) * 100);
    }
  }
  
  return roc;
}

// MFI (Money Flow Index)
function calculateMFI(data, period = 14) {
  const mfi = [];
  const typicalPrice = data.map(d => (d.high + d.low + d.close) / 3);
  const moneyFlow = typicalPrice.map((tp, i) => tp * (data[i].volume || 1));
  
  for (let i = 0; i < data.length; i++) {
    if (i < period) {
      mfi.push(null);
    } else {
      let posFlow = 0;
      let negFlow = 0;
      
      for (let j = i - period + 1; j <= i; j++) {
        if (typicalPrice[j] > typicalPrice[j - 1]) {
          posFlow += moneyFlow[j];
        } else {
          negFlow += moneyFlow[j];
        }
      }
      
      if (negFlow === 0) {
        mfi.push(100);
      } else {
        const mfRatio = posFlow / negFlow;
        mfi.push(100 - (100 / (1 + mfRatio)));
      }
    }
  }
  
  return mfi;
}

// ADX
function calculateADX(data, period = 14) {
  const tr = [];
  const plusDM = [];
  const minusDM = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      tr.push(data[i].high - data[i].low);
      plusDM.push(0);
      minusDM.push(0);
    } else {
      const hl = data[i].high - data[i].low;
      const hc = Math.abs(data[i].high - data[i - 1].close);
      const lc = Math.abs(data[i].low - data[i - 1].close);
      tr.push(Math.max(hl, hc, lc));
      
      const upMove = data[i].high - data[i - 1].high;
      const downMove = data[i - 1].low - data[i].low;
      
      plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
      minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
    }
  }
  
  const atr = calculateATR(data, period);
  const plusDI = [];
  const minusDI = [];
  const dx = [];
  const adx = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      plusDI.push(null);
      minusDI.push(null);
      dx.push(null);
      adx.push(null);
    } else {
      const smoothPlusDM = plusDM.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
      const smoothMinusDM = minusDM.slice(i - period + 1, i + 1).reduce((a, b) => a + b) / period;
      
      plusDI.push(atr[i] === 0 ? 0 : (smoothPlusDM / atr[i]) * 100);
      minusDI.push(atr[i] === 0 ? 0 : (smoothMinusDM / atr[i]) * 100);
      
      const diSum = plusDI[i] + minusDI[i];
      dx.push(diSum === 0 ? 0 : (Math.abs(plusDI[i] - minusDI[i]) / diSum) * 100);
      
      if (i < period * 2 - 2) {
        adx.push(null);
      } else if (i === period * 2 - 2) {
        adx.push(dx.slice(period - 1, period * 2 - 1).reduce((a, b) => a + b) / period);
      } else {
        adx.push((adx[i - 1] * (period - 1) + dx[i]) / period);
      }
    }
  }
  
  return { adx, plusDI, minusDI };
}

// OBV (On Balance Volume)
function calculateOBV(data) {
  const obv = [];
  let cumulative = 0;
  
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      obv.push(data[i].volume || 0);
      cumulative = data[i].volume || 0;
    } else {
      if (data[i].close > data[i - 1].close) {
        cumulative += (data[i].volume || 0);
      } else if (data[i].close < data[i - 1].close) {
        cumulative -= (data[i].volume || 0);
      }
      obv.push(cumulative);
    }
  }
  
  return obv;
}

// VWAP
function calculateVWAP(data) {
  const vwap = [];
  let cumulativePV = 0;
  let cumulativeV = 0;
  
  for (let i = 0; i < data.length; i++) {
    const typical = (data[i].high + data[i].low + data[i].close) / 3;
    const volume = data[i].volume || 1;
    cumulativePV += typical * volume;
    cumulativeV += volume;
    vwap.push(cumulativeV === 0 ? typical : cumulativePV / cumulativeV);
  }
  
  return vwap;
}

// Standard Deviation
function calculateStdDev(data, period = 20) {
  const stdDev = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i < period - 1) {
      stdDev.push(null);
    } else {
      const slice = data.slice(i - period + 1, i + 1).map(d => d.close);
      const mean = slice.reduce((a, b) => a + b) / period;
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
      stdDev.push(Math.sqrt(variance));
    }
  }
  
  return stdDev;
}

// Pivot Points
function calculatePivotPoints(data) {
  const pivots = [];
  
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      pivots.push({
        pp: null, r1: null, r2: null, r3: null,
        s1: null, s2: null, s3: null
      });
    } else {
      const pp = (data[i - 1].high + data[i - 1].low + data[i - 1].close) / 3;
      const r1 = 2 * pp - data[i - 1].low;
      const s1 = 2 * pp - data[i - 1].high;
      const r2 = pp + (data[i - 1].high - data[i - 1].low);
      const s2 = pp - (data[i - 1].high - data[i - 1].low);
      const r3 = data[i - 1].high + 2 * (pp - data[i - 1].low);
      const s3 = data[i - 1].low - 2 * (data[i - 1].high - pp);
      
      pivots.push({ pp, r1, r2, r3, s1, s2, s3 });
    }
  }
  
  return pivots;
}

// Ichimoku Cloud
function calculateIchimoku(data, tenkan = 9, kijun = 26, senkouB = 52, displacement = 26) {
  const ichimoku = [];
  
  const getHighLow = (data, start, end) => {
    if (start < 0) return { high: null, low: null };
    const slice = data.slice(start, end + 1);
    return {
      high: Math.max(...slice.map(d => d.high)),
      low: Math.min(...slice.map(d => d.low))
    };
  };
  
  for (let i = 0; i < data.length; i++) {
    const tenkanHL = getHighLow(data, i - tenkan + 1, i);
    const kijunHL = getHighLow(data, i - kijun + 1, i);
    const senkouBHL = getHighLow(data, i - senkouB + 1, i);
    
    const tenkanSen = tenkanHL.high !== null ? (tenkanHL.high + tenkanHL.low) / 2 : null;
    const kijunSen = kijunHL.high !== null ? (kijunHL.high + kijunHL.low) / 2 : null;
    const senkouSpanB = senkouBHL.high !== null ? (senkouBHL.high + senkouBHL.low) / 2 : null;
    const senkouSpanA = tenkanSen !== null && kijunSen !== null ? (tenkanSen + kijunSen) / 2 : null;
    const chikouSpan = data[i].close;
    
    ichimoku.push({
      tenkanSen,
      kijunSen,
      senkouSpanA,
      senkouSpanB,
      chikouSpan
    });
  }
  
  return ichimoku;
}

// Keltner Channels
function calculateKeltnerChannels(data, period = 20, atrPeriod = 10, multiplier = 2) {
  const ema = calculateEMA(data, period);
  const atr = calculateATR(data, atrPeriod);
  
  const upper = ema.map((e, i) => e !== null && atr[i] !== null ? e + multiplier * atr[i] : null);
  const lower = ema.map((e, i) => e !== null && atr[i] !== null ? e - multiplier * atr[i] : null);
  
  return { upper, middle: ema, lower };
}

// Parabolic SAR
function calculateParabolicSAR(data, step = 0.02, max = 0.2) {
  const sar = [];
  let isUptrend = true;
  let af = step;
  let ep = data[0].high;
  let sarValue = data[0].low;
  
  for (let i = 0; i < data.length; i++) {
    if (i === 0) {
      sar.push(sarValue);
      continue;
    }
    
    sarValue = sarValue + af * (ep - sarValue);
    
    if (isUptrend) {
      if (data[i].low < sarValue) {
        isUptrend = false;
        sarValue = ep;
        ep = data[i].low;
        af = step;
      } else {
        if (data[i].high > ep) {
          ep = data[i].high;
          af = Math.min(af + step, max);
        }
        sarValue = Math.min(sarValue, data[i - 1].low, i > 1 ? data[i - 2].low : data[i - 1].low);
      }
    } else {
      if (data[i].high > sarValue) {
        isUptrend = true;
        sarValue = ep;
        ep = data[i].high;
        af = step;
      } else {
        if (data[i].low < ep) {
          ep = data[i].low;
          af = Math.min(af + step, max);
        }
        sarValue = Math.max(sarValue, data[i - 1].high, i > 1 ? data[i - 2].high : data[i - 1].high);
      }
    }
    
    sar.push(sarValue);
  }
  
  return sar;
}

// Function to calculate all indicators
function calculateAllIndicators(data) {
  console.log('Calculating all indicators...');
  
  const indicators = {};
  
  indicators.returns = calculateReturns(data);
  indicators.hl = calculateHL(data);
  indicators.oc = calculateOC(data);
  indicators.bodyPct = calculateBodyPct(data);
  
  indicators.sma5 = calculateSMA(data, 5);
  indicators.sma10 = calculateSMA(data, 10);
  indicators.sma20 = calculateSMA(data, 20);
  indicators.sma50 = calculateSMA(data, 50);
  indicators.sma100 = calculateSMA(data, 100);
  indicators.sma200 = calculateSMA(data, 200);
  
  indicators.ema5 = calculateEMA(data, 5);
  indicators.ema10 = calculateEMA(data, 10);
  indicators.ema12 = calculateEMA(data, 12);
  indicators.ema20 = calculateEMA(data, 20);
  indicators.ema26 = calculateEMA(data, 26);
  indicators.ema50 = calculateEMA(data, 50);
  indicators.ema100 = calculateEMA(data, 100);
  indicators.ema200 = calculateEMA(data, 200);
  
  indicators.wma10 = calculateWMA(data, 10);
  indicators.wma20 = calculateWMA(data, 20);
  indicators.wma50 = calculateWMA(data, 50);
  
  indicators.rsi7 = calculateRSI(data, 7);
  indicators.rsi14 = calculateRSI(data, 14);
  indicators.rsi21 = calculateRSI(data, 21);
  
  const macd = calculateMACD(data);
  indicators.macdLine = macd.macdLine;
  indicators.macdSignal = macd.signalLine;
  indicators.macdHistogram = macd.histogram;
  
  const stoch = calculateStochastic(data);
  indicators.stochK = stoch.k;
  indicators.stochD = stoch.d;
  
  indicators.atr14 = calculateATR(data, 14);
  indicators.atr20 = calculateATR(data, 20);
  
  const bb = calculateBollingerBands(data);
  indicators.bbUpper = bb.upper;
  indicators.bbMiddle = bb.middle;
  indicators.bbLower = bb.lower;
  indicators.bbBandwidth = bb.bandwidth;
  
  indicators.cci20 = calculateCCI(data, 20);
  indicators.williamsR14 = calculateWilliamsR(data, 14);
  indicators.roc12 = calculateROC(data, 12);
  indicators.mfi14 = calculateMFI(data, 14);
  
  const adx = calculateADX(data);
  indicators.adx14 = adx.adx;
  indicators.plusDI = adx.plusDI;
  indicators.minusDI = adx.minusDI;
  
  indicators.obv = calculateOBV(data);
  indicators.vwap = calculateVWAP(data);
  indicators.stdDev20 = calculateStdDev(data, 20);
  
  const pivots = calculatePivotPoints(data);
  indicators.pivotPoint = pivots.map(p => p.pp);
  indicators.r1 = pivots.map(p => p.r1);
  indicators.r2 = pivots.map(p => p.r2);
  indicators.r3 = pivots.map(p => p.r3);
  indicators.s1 = pivots.map(p => p.s1);
  indicators.s2 = pivots.map(p => p.s2);
  indicators.s3 = pivots.map(p => p.s3);
  
  const ichimoku = calculateIchimoku(data);
  indicators.ichimokuTenkan = ichimoku.map(i => i.tenkanSen);
  indicators.ichimokuKijun = ichimoku.map(i => i.kijunSen);
  indicators.ichimokuSenkouA = ichimoku.map(i => i.senkouSpanA);
  indicators.ichimokuSenkouB = ichimoku.map(i => i.senkouSpanB);
  indicators.ichimokuChikou = ichimoku.map(i => i.chikouSpan);
  
  const keltner = calculateKeltnerChannels(data);
  indicators.keltnerUpper = keltner.upper;
  indicators.keltnerMiddle = keltner.middle;
  indicators.keltnerLower = keltner.lower;
  
  indicators.psar = calculateParabolicSAR(data);
  
  console.log('All indicators calculated successfully!');
  return indicators;
}

// Strategy: Immediate Signal Test (RSI + MA Crossover)
function immediateSignalStrategy(data) {
  const signals = [];
  const sma20 = calculateSMA(data, 20);
  const sma50 = calculateSMA(data, 50);
  const rsi = calculateRSI(data, 14);

  for (let i = 50; i < data.length; i++) {
    if (sma20[i] && sma50[i] && rsi[i]) {
      if (sma20[i] > sma50[i] && sma20[i - 1] <= sma50[i - 1] && rsi[i] < 70) {
        signals.push({ time: data[i].time, position: 'belowBar', color: '#0f0', shape: 'arrowUp', text: 'BUY' });
      }
      else if (sma20[i] < sma50[i] && sma20[i - 1] >= sma50[i - 1] && rsi[i] > 30) {
        signals.push({ time: data[i].time, position: 'aboveBar', color: '#f33', shape: 'arrowDown', text: 'SELL' });
      }
    }
  }

  return signals;
}

// Strategy: Random Strategy (Multiple Indicators) - Fixed to be deterministic
function randomStrategy(data) {
  const signals = [];
  const ema12 = calculateEMA(data, 12);
  const ema26 = calculateEMA(data, 26);
  const rsi = calculateRSI(data, 14);
  const macd = calculateMACD(data);

  for (let i = 30; i < data.length; i++) {
    if (ema12[i] && ema26[i] && rsi[i] && macd.histogram[i]) {
      if (ema12[i] > ema26[i] && rsi[i] < 40 && macd.histogram[i] > 0) {
        signals.push({ time: data[i].time, position: 'belowBar', color: '#0f0', shape: 'arrowUp', text: 'BUY' });
      }
      else if (ema12[i] < ema26[i] && rsi[i] > 60 && macd.histogram[i] < 0) {
        signals.push({ time: data[i].time, position: 'aboveBar', color: '#f33', shape: 'arrowDown', text: 'SELL' });
      }
      else if (rsi[i] < 30 && macd.histogram[i] > 0) {
        signals.push({ time: data[i].time, position: 'belowBar', color: '#0ff', shape: 'circle', text: 'R-BUY' });
      }
      else if (rsi[i] > 70 && macd.histogram[i] < 0) {
        signals.push({ time: data[i].time, position: 'aboveBar', color: '#ff0', shape: 'circle', text: 'R-SELL' });
      }
    }
  }

  return signals;
}

function markChartReady() {
  chartReady = true;
  console.log('Chart marked as ready for strategy execution');
  if (currentStrategy) {
    applyCurrentStrategy();
  }
}

function applyCurrentStrategy() {
  if (!chartReady || data.length === 0) return;

  let newMarkers = [];

  if (currentStrategy === 'immediate') {
    newMarkers = immediateSignalStrategy(data);
    updateStrategyStatus('Active: Immediate Signal Test');
  } else if (currentStrategy === 'random') {
    newMarkers = randomStrategy(data);
    updateStrategyStatus('Active: Random Strategy');
  } else if (currentStrategy === 'custom' && customStrategyFunc) {
    try {
      newMarkers = customStrategyFunc(data) || [];
      updateStrategyStatus('Active: Custom Strategy');
    } catch (err) {
      console.error('Custom strategy error:', err);
      updateStrategyStatus('Error in custom strategy');
      return;
    }
  }

  markers = newMarkers;
  series.setMarkers(markers);
  lastProcessedIndex = data.length - 1;
  console.log(`Applied ${currentStrategy} strategy: ${markers.length} signals generated`);
}

function applyStrategyIncremental() {
  if (!chartReady || data.length === 0 || !currentStrategy) return;

  if (lastProcessedIndex >= data.length - 1) return;

  const lookbackCandles = 60;
  const startIndex = Math.max(0, data.length - lookbackCandles);

  const timeThreshold = data[startIndex].time;
  const preservedMarkers = markers.filter(m => m.time < timeThreshold);

  let newMarkers = [];
  const recalcData = data.slice(startIndex);

  if (currentStrategy === 'immediate') {
    newMarkers = immediateSignalStrategy(recalcData);
  } else if (currentStrategy === 'random') {
    newMarkers = randomStrategy(recalcData);
  } else if (currentStrategy === 'custom' && customStrategyFunc) {
    try {
      newMarkers = customStrategyFunc(recalcData) || [];
    } catch (err) {
      console.error('Custom strategy error:', err);
      return;
    }
  }

  markers = [...preservedMarkers, ...newMarkers];
  series.setMarkers(markers);
  lastProcessedIndex = data.length - 1;
}

function updateStrategyStatus(text) {
  const statusEl = document.getElementById('strategyStatus');
  statusEl.textContent = text ? `(${text})` : '';
}

function updateStatus(txt, cls) {
  const s = document.getElementById('status');
  s.className = cls;
  s.textContent = txt;
}

function setInfo(txt) {
  document.getElementById('infoTxt').textContent = txt;
}

function setPair(txt) {
  document.getElementById('pair').textContent = txt;
}

function showSpinner(main, sub) {
  const sp = document.getElementById('spinner');
  const txt = document.getElementById('spinner-text');
  const subTxt = document.getElementById('spinner-sub');
  const fill = document.getElementById('progress-fill');
  txt.textContent = main;
  subTxt.textContent = sub || '';
  fill.style.width = '0%';
  sp.style.display = 'block';
}

function hideSpinner() {
  document.getElementById('spinner').style.display = 'none';
}

function updateProgress(pct) {
  document.getElementById('progress-fill').style.width = `${pct}%`;
}

function fmtDate(ts) {
  const d = new Date(ts * 1000);
  return d.toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }).replace(',', '');
}

function toDateStr(ts) {
  const d = new Date(ts * 1000);
  const Y = d.getUTCFullYear();
  const M = String(d.getUTCMonth() + 1).padStart(2, '0');
  const D = String(d.getUTCDate()).padStart(2, '0');
  const h = String(d.getUTCHours()).padStart(2, '0');
  const m = String(d.getUTCMinutes()).padStart(2, '0');
  const s = String(d.getUTCSeconds()).padStart(2, '0');
  return `${Y}-${M}-${D} ${h}:${m}:${s}`;
}

function initChart() {
  const container = document.getElementById('chart');
  chart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#000' }, textColor: '#fff' },
    grid: { vertLines: { color: '#111' }, horzLines: { color: '#111' } },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    timeScale: { timeVisible: true, secondsVisible: false }
  });
  series = chart.addCandlestickSeries({
    upColor: '#0f0', downColor: '#f33',
    borderUpColor: '#0f0', borderDownColor: '#f33',
    wickUpColor: '#0f0', wickDownColor: '#f33'
  });
  chart.timeScale().fitContent();

  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    chart.resize(w, h);
  });

  markChartReady();
}

function loadSymbols(cat) {
  const s = document.getElementById('sym');
  s.innerHTML = '<option>Loading...</option>';
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    s.innerHTML = '<option>Error: Not connected</option>';
    return;
  }
  socket.send(JSON.stringify({ active_symbols: cat, product_type: 'basic' }));
}

function processOHLC(arr, epoch) {
  return { time: epoch, open: arr[0], high: arr[1], low: arr[2], close: arr[3] };
}

function renderData(skipFit) {
  if (data.length === 0) return;
  series.setData(data);
  if (!skipFit) chart.timeScale().fitContent();
  applyCurrentStrategy();
}

function startCountdown(nextCandle) {
  if (countdownInterval) clearInterval(countdownInterval);
  const cd = document.getElementById('countdown');

  countdownInterval = setInterval(() => {
    const now = Math.floor(Date.now() / 1000);
    const diff = nextCandle - now;
    if (diff <= 0) {
      cd.textContent = '00:00';
      return;
    }
    const min = Math.floor(diff / 60);
    const sec = diff % 60;
    cd.textContent = `${String(min).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
  }, 1000);
}

function loadHistorical() {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    alert('Not connected to server');
    return;
  }
  data = [];
  markers = [];
  rangeStart = null;
  rangeEnd = null;
  const cnt = parseInt(document.getElementById('cnt').value, 10);
  const tf = parseInt(document.getElementById('tf').value, 10);
  showSpinner('Loading Historical Data...', `Fetching last ${cnt} candles`);
  socket.send(JSON.stringify({ ticks_history: sym, adjust_start_time: 1, count: cnt, end: 'latest', start: 1, style: 'candles', granularity: tf }));
}

async function fetchRange() {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    alert('Not connected');
    return;
  }
  const df = document.getElementById('df').value;
  const dt = document.getElementById('dt').value;
  if (!df || !dt) {
    alert('Please select both dates');
    return;
  }
  const start = Math.floor(new Date(df + 'T00:00:00Z').getTime() / 1000);
  const end = Math.floor(new Date(dt + 'T23:59:59Z').getTime() / 1000);
  if (start >= end) {
    alert('From date must be before To date');
    return;
  }

  data = [];
  markers = [];
  rangeStart = start;
  rangeEnd = end;
  const tf = parseInt(document.getElementById('tf').value, 10);
  const totalSeconds = end - start;
  const candlesEstimate = Math.ceil(totalSeconds / tf);

  showSpinner('Fetching Date Range...', `Estimated: ${candlesEstimate.toLocaleString()} candles`);

  let currentStart = start;
  let batchNum = 0;

  while (currentStart < end) {
    batchNum++;
    const batchEnd = Math.min(currentStart + BATCH * tf, end);
    const count = Math.ceil((batchEnd - currentStart) / tf);
    updateProgress((currentStart - start) / totalSeconds * 100);

    await new Promise((resolve) => {
      const reqId = `range_${batchNum}`;
      const listener = (msg) => {
        const d = JSON.parse(msg.data);
        if (d.echo_req && d.echo_req.req_id === reqId) {
          if (d.candles) {
            const chunk = d.candles.map(c => processOHLC(c.ohlc, c.epoch));
            data = [...data, ...chunk];
            console.log(`Batch ${batchNum}: fetched ${chunk.length} candles`);
          }
          socket.removeEventListener('message', listener);
          resolve();
        }
      };
      socket.addEventListener('message', listener);
      socket.send(JSON.stringify({ ticks_history: sym, adjust_start_time: 1, count, end: batchEnd, start: currentStart, style: 'candles', granularity: tf, req_id: reqId }));
    });

    currentStart += BATCH * tf;

    if (data.length > MAX) {
      hideSpinner();
      alert(`Dataset exceeds ${MAX.toLocaleString()} candles. Please reduce date range.`);
      data = [];
      return;
    }
  }

  updateProgress(100);
  hideSpinner();
  renderData();
  const d1 = toDateStr(data[0].time);
  const d2 = toDateStr(data[data.length - 1].time);
  setInfo(`${data.length.toLocaleString()} candles | ${d1} ‚Üí ${d2}`);
  alert(`Loaded ${data.length.toLocaleString()} candles`);
}

function startLive() {
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    alert('Not connected');
    return;
  }
  if (data.length === 0) {
    alert('Load historical data first');
    return;
  }
  socket.send(JSON.stringify({ ticks_history: sym, adjust_start_time: 1, count: 1, end: 'latest', start: 1, style: 'candles', granularity: gran, subscribe: 1 }));
}

function downloadCSV() {
  if (data.length === 0) {
    alert('No data to export');
    return;
  }

  console.log('Generating CSV with all indicators...');
  
  const allIndicators = calculateAllIndicators(data);
  
  let csv = 'Timestamp,Date,Open,High,Low,Close,';
  csv += 'Returns,HL_Range,OC_Range,Body_Pct,';
  csv += 'SMA_5,SMA_10,SMA_20,SMA_50,SMA_100,SMA_200,';
  csv += 'EMA_5,EMA_10,EMA_12,EMA_20,EMA_26,EMA_50,EMA_100,EMA_200,';
  csv += 'WMA_10,WMA_20,WMA_50,';
  csv += 'RSI_7,RSI_14,RSI_21,';
  csv += 'MACD_Line,MACD_Signal,MACD_Histogram,';
  csv += 'Stoch_K,Stoch_D,';
  csv += 'ATR_14,ATR_20,';
  csv += 'BB_Upper,BB_Middle,BB_Lower,BB_Bandwidth,';
  csv += 'CCI_20,Williams_R_14,ROC_12,MFI_14,';
  csv += 'ADX_14,Plus_DI,Minus_DI,';
  csv += 'OBV,VWAP,StdDev_20,';
  csv += 'Pivot_Point,R1,R2,R3,S1,S2,S3,';
  csv += 'Ichimoku_Tenkan,Ichimoku_Kijun,Ichimoku_SenkouA,Ichimoku_SenkouB,Ichimoku_Chikou,';
  csv += 'Keltner_Upper,Keltner_Middle,Keltner_Lower,';
  csv += 'Parabolic_SAR\n';

  data.forEach((row, i) => {
    const dateStr = toDateStr(row.time);
    csv += `${row.time},${dateStr},${row.open},${row.high},${row.low},${row.close},`;
    csv += `${allIndicators.returns[i] ?? ''},${allIndicators.hl[i] ?? ''},${allIndicators.oc[i] ?? ''},${allIndicators.bodyPct[i] ?? ''},`;
    csv += `${allIndicators.sma5[i] ?? ''},${allIndicators.sma10[i] ?? ''},${allIndicators.sma20[i] ?? ''},${allIndicators.sma50[i] ?? ''},${allIndicators.sma100[i] ?? ''},${allIndicators.sma200[i] ?? ''},`;
    csv += `${allIndicators.ema5[i] ?? ''},${allIndicators.ema10[i] ?? ''},${allIndicators.ema12[i] ?? ''},${allIndicators.ema20[i] ?? ''},${allIndicators.ema26[i] ?? ''},${allIndicators.ema50[i] ?? ''},${allIndicators.ema100[i] ?? ''},${allIndicators.ema200[i] ?? ''},`;
    csv += `${allIndicators.wma10[i] ?? ''},${allIndicators.wma20[i] ?? ''},${allIndicators.wma50[i] ?? ''},`;
    csv += `${allIndicators.rsi7[i] ?? ''},${allIndicators.rsi14[i] ?? ''},${allIndicators.rsi21[i] ?? ''},`;
    csv += `${allIndicators.macdLine[i] ?? ''},${allIndicators.macdSignal[i] ?? ''},${allIndicators.macdHistogram[i] ?? ''},`;
    csv += `${allIndicators.stochK[i] ?? ''},${allIndicators.stochD[i] ?? ''},`;
    csv += `${allIndicators.atr14[i] ?? ''},${allIndicators.atr20[i] ?? ''},`;
    csv += `${allIndicators.bbUpper[i] ?? ''},${allIndicators.bbMiddle[i] ?? ''},${allIndicators.bbLower[i] ?? ''},${allIndicators.bbBandwidth[i] ?? ''},`;
    csv += `${allIndicators.cci20[i] ?? ''},${allIndicators.williamsR14[i] ?? ''},${allIndicators.roc12[i] ?? ''},${allIndicators.mfi14[i] ?? ''},`;
    csv += `${allIndicators.adx14[i] ?? ''},${allIndicators.plusDI[i] ?? ''},${allIndicators.minusDI[i] ?? ''},`;
    csv += `${allIndicators.obv[i] ?? ''},${allIndicators.vwap[i] ?? ''},${allIndicators.stdDev20[i] ?? ''},`;
    csv += `${allIndicators.pivotPoint[i] ?? ''},${allIndicators.r1[i] ?? ''},${allIndicators.r2[i] ?? ''},${allIndicators.r3[i] ?? ''},${allIndicators.s1[i] ?? ''},${allIndicators.s2[i] ?? ''},${allIndicators.s3[i] ?? ''},`;
    csv += `${allIndicators.ichimokuTenkan[i] ?? ''},${allIndicators.ichimokuKijun[i] ?? ''},${allIndicators.ichimokuSenkouA[i] ?? ''},${allIndicators.ichimokuSenkouB[i] ?? ''},${allIndicators.ichimokuChikou[i] ?? ''},`;
    csv += `${allIndicators.keltnerUpper[i] ?? ''},${allIndicators.keltnerMiddle[i] ?? ''},${allIndicators.keltnerLower[i] ?? ''},`;
    csv += `${allIndicators.psar[i] ?? ''}\n`;
  });

  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${sym}_${gran}s_with_indicators.csv`;
  a.click();
  URL.revokeObjectURL(url);
  
  console.log('CSV export with all indicators completed!');
}

function downloadXLSX() {
  if (data.length === 0) {
    alert('No data to export');
    return;
  }

  console.log('Generating XLSX with all indicators...');
  
  const allIndicators = calculateAllIndicators(data);
  
  const rows = data.map((row, i) => ({
    Timestamp: row.time,
    Date: toDateStr(row.time),
    Open: row.open,
    High: row.high,
    Low: row.low,
    Close: row.close,
    Returns: allIndicators.returns[i],
    HL_Range: allIndicators.hl[i],
    OC_Range: allIndicators.oc[i],
    Body_Pct: allIndicators.bodyPct[i],
    SMA_5: allIndicators.sma5[i],
    SMA_10: allIndicators.sma10[i],
    SMA_20: allIndicators.sma20[i],
    SMA_50: allIndicators.sma50[i],
    SMA_100: allIndicators.sma100[i],
    SMA_200: allIndicators.sma200[i],
    EMA_5: allIndicators.ema5[i],
    EMA_10: allIndicators.ema10[i],
    EMA_12: allIndicators.ema12[i],
    EMA_20: allIndicators.ema20[i],
    EMA_26: allIndicators.ema26[i],
    EMA_50: allIndicators.ema50[i],
    EMA_100: allIndicators.ema100[i],
    EMA_200: allIndicators.ema200[i],
    WMA_10: allIndicators.wma10[i],
    WMA_20: allIndicators.wma20[i],
    WMA_50: allIndicators.wma50[i],
    RSI_7: allIndicators.rsi7[i],
    RSI_14: allIndicators.rsi14[i],
    RSI_21: allIndicators.rsi21[i],
    MACD_Line: allIndicators.macdLine[i],
    MACD_Signal: allIndicators.macdSignal[i],
    MACD_Histogram: allIndicators.macdHistogram[i],
    Stoch_K: allIndicators.stochK[i],
    Stoch_D: allIndicators.stochD[i],
    ATR_14: allIndicators.atr14[i],
    ATR_20: allIndicators.atr20[i],
    BB_Upper: allIndicators.bbUpper[i],
    BB_Middle: allIndicators.bbMiddle[i],
    BB_Lower: allIndicators.bbLower[i],
    BB_Bandwidth: allIndicators.bbBandwidth[i],
    CCI_20: allIndicators.cci20[i],
    Williams_R_14: allIndicators.williamsR14[i],
    ROC_12: allIndicators.roc12[i],
    MFI_14: allIndicators.mfi14[i],
    ADX_14: allIndicators.adx14[i],
    Plus_DI: allIndicators.plusDI[i],
    Minus_DI: allIndicators.minusDI[i],
    OBV: allIndicators.obv[i],
    VWAP: allIndicators.vwap[i],
    StdDev_20: allIndicators.stdDev20[i],
    Pivot_Point: allIndicators.pivotPoint[i],
    R1: allIndicators.r1[i],
    R2: allIndicators.r2[i],
    R3: allIndicators.r3[i],
    S1: allIndicators.s1[i],
    S2: allIndicators.s2[i],
    S3: allIndicators.s3[i],
    Ichimoku_Tenkan: allIndicators.ichimokuTenkan[i],
    Ichimoku_Kijun: allIndicators.ichimokuKijun[i],
    Ichimoku_SenkouA: allIndicators.ichimokuSenkouA[i],
    Ichimoku_SenkouB: allIndicators.ichimokuSenkouB[i],
    Ichimoku_Chikou: allIndicators.ichimokuChikou[i],
    Keltner_Upper: allIndicators.keltnerUpper[i],
    Keltner_Middle: allIndicators.keltnerMiddle[i],
    Keltner_Lower: allIndicators.keltnerLower[i],
    Parabolic_SAR: allIndicators.psar[i]
  }));

  const ws = XLSX.utils.json_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Data');
  XLSX.writeFile(wb, `${sym}_${gran}s_with_indicators.xlsx`);
  
  console.log('XLSX export with all indicators completed!');
}

function runBacktest() {
  if (data.length === 0 || markers.length === 0) {
    alert('No data or signals');
    return;
  }
  const slP = parseFloat(document.getElementById('slP').value) || 0;
  const tpP = parseFloat(document.getElementById('tpP').value) || 0;
  const hold = parseInt(document.getElementById('hold').value, 10) || 5;

  let wins = 0, losses = 0, totalProfit = 0;

  markers.forEach(m => {
    const idx = data.findIndex(d => d.time === m.time);
    if (idx === -1 || idx + hold >= data.length) return;

    const entry = data[idx].close;
    const side = m.text.includes('BUY') ? 'buy' : 'sell';
    let pnl = 0;
    let hit = false;

    for (let i = idx + 1; i <= idx + hold; i++) {
      const c = data[i].close;
      const diff = side === 'buy' ? (c - entry) / entry * 100 : (entry - c) / entry * 100;

      if (tpP > 0 && diff >= tpP) {
        pnl = tpP;
        hit = true;
        break;
      }
      if (slP > 0 && diff <= -slP) {
        pnl = -slP;
        hit = true;
        break;
      }

      if (i === idx + hold) {
        pnl = diff;
      }
    }

    totalProfit += pnl;
    if (pnl > 0) wins++;
    else if (pnl < 0) losses++;
  });

  const total = wins + losses;
  const winRate = total > 0 ? (wins / total * 100).toFixed(2) : 0;
  document.getElementById('results').innerHTML = `
    Total Trades: ${total}<br>
    Wins: ${wins} | Losses: ${losses}<br>
    Win Rate: ${winRate}%<br>
    Total P/L: ${totalProfit.toFixed(2)}%
  `;
}

function clearBacktest() {
  document.getElementById('results').innerHTML = 'Run a backtest to see results';
}

function connectWS() {
  socket = new WebSocket(WS_URL);

  socket.addEventListener('open', () => {
    updateStatus('üü¢ Connected', 's-green');
    socket.send(JSON.stringify({ website_status: 1 }));
  });

  socket.addEventListener('close', () => {
    updateStatus('üî¥ Disconnected', 's-red');
  });

  socket.addEventListener('error', () => {
    updateStatus('üî¥ Connection Error', 's-red');
  });

  socket.addEventListener('message', (msg) => {
    const d = JSON.parse(msg.data);

    if (d.website_status && d.website_status.currencies_config) {
      const cats = Object.keys(d.website_status.currencies_config).map(k => ({
        id: k.toLowerCase(),
        name: d.website_status.currencies_config[k].name
      }));
      const cat = document.getElementById('cat');
      cat.innerHTML = cats.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
      loadSymbols(cats[0].id);
    }

    if (d.active_symbols) {
      const symEl = document.getElementById('sym');
      const filtered = d.active_symbols.filter(s => s.market === 'forex' || s.market === 'indices' || s.market === 'commodities' || s.market === 'synthetic_index');
      symEl.innerHTML = filtered.map(s => `<option value="${s.symbol}">${s.display_name}</option>`).join('');
      sym = filtered[0].symbol;
      setPair(filtered[0].display_name);
    }

    if (d.candles && !d.subscription) {
      const candles = d.candles.map(c => processOHLC(c.ohlc, c.epoch));
      data = candles;
      hideSpinner();
      renderData();
      const d1 = toDateStr(data[0].time);
      const d2 = toDateStr(data[data.length - 1].time);
      setInfo(`${data.length.toLocaleString()} candles | ${d1} ‚Üí ${d2}`);
    }

    if (d.ohlc && d.subscription) {
      const candle = processOHLC(d.ohlc.ohlc, d.ohlc.epoch);
      const lastIdx = data.findIndex(c => c.time === candle.time);

      if (lastIdx !== -1) {
        data[lastIdx] = candle;
      } else {
        data.push(candle);
      }

      renderData(true);
      applyStrategyIncremental();
      const nextCandle = candle.time + gran;
      startCountdown(nextCandle);
      updateStatus('üü¢ Live Stream', 's-green');
    }
  });
}

document.getElementById('cat').addEventListener('change', e => loadSymbols(e.target.value));
document.getElementById('sym').addEventListener('change', e => {
  sym = e.target.value;
  const opt = e.target.selectedOptions[0];
  setPair(opt.textContent);
});
document.getElementById('tf').addEventListener('change', e => {
  gran = parseInt(e.target.value, 10);
});
document.getElementById('loadH').addEventListener('click', loadHistorical);
document.getElementById('fetchR').addEventListener('click', fetchRange);
document.getElementById('live').addEventListener('click', startLive);
document.getElementById('csv').addEventListener('click', downloadCSV);
document.getElementById('xlsx').addEventListener('click', downloadXLSX);
document.getElementById('runBt').addEventListener('click', runBacktest);
document.getElementById('clr').addEventListener('click', clearBacktest);
document.getElementById('scrollStart').addEventListener('click', () => {
  if (data.length > 0) chart.timeScale().scrollToPosition(-data.length, false);
});
document.getElementById('scrollEnd').addEventListener('click', () => {
  if (data.length > 0) chart.timeScale().scrollToRealTime();
});

document.getElementById('bt').addEventListener('click', () => {
  const drawer = document.getElementById('drawer');
  drawer.classList.toggle('open');
});

document.getElementById('strategyBtn').addEventListener('click', (e) => {
  e.stopPropagation();
  const dropdown = document.getElementById('strategyDropdown');
  dropdown.classList.toggle('show');
});

document.addEventListener('click', () => {
  const dropdown = document.getElementById('strategyDropdown');
  dropdown.classList.remove('show');
});

document.getElementById('stratImmediate').addEventListener('click', () => {
  currentStrategy = 'immediate';
  customStrategyFunc = null;
  applyCurrentStrategy();
  document.getElementById('strategyDropdown').classList.remove('show');
});

document.getElementById('stratRandom').addEventListener('click', () => {
  currentStrategy = 'random';
  customStrategyFunc = null;
  applyCurrentStrategy();
  document.getElementById('strategyDropdown').classList.remove('show');
});

document.getElementById('stratPaste').addEventListener('click', () => {
  document.getElementById('strategyModal').classList.add('show');
  document.getElementById('strategyDropdown').classList.remove('show');
});

document.getElementById('modalCancel').addEventListener('click', () => {
  document.getElementById('strategyModal').classList.remove('show');
});

document.getElementById('modalApply').addEventListener('click', () => {
  const code = document.getElementById('strategyCode').value.trim();
  if (!code) {
    alert('Please paste your strategy code');
    return;
  }

  try {
    eval(code);
    if (typeof customStrategy === 'function') {
      customStrategyFunc = customStrategy;
      currentStrategy = 'custom';
      applyCurrentStrategy();
      document.getElementById('strategyModal').classList.remove('show');
      alert('Custom strategy applied successfully!');
    } else {
      alert('Strategy code must define a function named "customStrategy"');
    }
  } catch (err) {
    alert('Error in strategy code: ' + err.message);
    console.error(err);
  }
});

document.getElementById('stratUpload').addEventListener('click', () => {
  document.getElementById('strategyFileInput').click();
  document.getElementById('strategyDropdown').classList.remove('show');
});

document.getElementById('strategyFileInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (event) => {
    const code = event.target.result;
    try {
      eval(code);
      if (typeof customStrategy === 'function') {
        customStrategyFunc = customStrategy;
        currentStrategy = 'custom';
        applyCurrentStrategy();
        alert('Custom strategy from file applied successfully!');
      } else {
        alert('File must define a function named "customStrategy"');
      }
    } catch (err) {
      alert('Error in strategy file: ' + err.message);
      console.error(err);
    }
  };
  reader.readAsText(file);
});

const today = new Date();
const yesterday = new Date(today);
yesterday.setDate(yesterday.getDate() - 1);
document.getElementById('df').value = yesterday.toISOString().split('T')[0];
document.getElementById('dt').value = today.toISOString().split('T')[0];

initChart();
connectWS();
}
</script>

</body>
</html>
